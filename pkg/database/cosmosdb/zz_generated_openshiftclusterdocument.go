// Code generated by github.com/jim-minter/go-cosmosdb, DO NOT EDIT.

package cosmosdb

import (
	"net/http"
	"strings"

	pkg "github.com/jim-minter/rp/pkg/api"
)

type openShiftClusterDocumentClient struct {
	*databaseClient
	path string
}

// OpenShiftClusterDocumentClient is a openShiftClusterDocument client
type OpenShiftClusterDocumentClient interface {
	Create(string, *pkg.OpenShiftClusterDocument, *Options) (*pkg.OpenShiftClusterDocument, error)
	List() OpenShiftClusterDocumentIterator
	ListAll() (*pkg.OpenShiftClusterDocuments, error)
	Get(string, string) (*pkg.OpenShiftClusterDocument, error)
	Replace(string, *pkg.OpenShiftClusterDocument, *Options) (*pkg.OpenShiftClusterDocument, error)
	Delete(string, *pkg.OpenShiftClusterDocument, *Options) error
	Query(string, *Query) OpenShiftClusterDocumentIterator
	QueryAll(string, *Query) (*pkg.OpenShiftClusterDocuments, error)
}

type openShiftClusterDocumentListIterator struct {
	*openShiftClusterDocumentClient
	continuation string
	done         bool
}

type openShiftClusterDocumentQueryIterator struct {
	*openShiftClusterDocumentClient
	partitionkey string
	query        *Query
	continuation string
	done         bool
}

// OpenShiftClusterDocumentIterator is a openShiftClusterDocument iterator
type OpenShiftClusterDocumentIterator interface {
	Next() (*pkg.OpenShiftClusterDocuments, error)
}

// NewOpenShiftClusterDocumentClient returns a new openShiftClusterDocument client
func NewOpenShiftClusterDocumentClient(collc CollectionClient, collid string) OpenShiftClusterDocumentClient {
	return &openShiftClusterDocumentClient{
		databaseClient: collc.(*collectionClient).databaseClient,
		path:           collc.(*collectionClient).path + "/colls/" + collid,
	}
}

func (c *openShiftClusterDocumentClient) all(i OpenShiftClusterDocumentIterator) (*pkg.OpenShiftClusterDocuments, error) {
	allopenShiftClusterDocuments := &pkg.OpenShiftClusterDocuments{}

	for {
		openShiftClusterDocuments, err := i.Next()
		if err != nil {
			return nil, err
		}
		if openShiftClusterDocuments == nil {
			break
		}

		allopenShiftClusterDocuments.Count += openShiftClusterDocuments.Count
		allopenShiftClusterDocuments.ResourceID = openShiftClusterDocuments.ResourceID
		allopenShiftClusterDocuments.OpenShiftClusterDocuments = append(allopenShiftClusterDocuments.OpenShiftClusterDocuments, openShiftClusterDocuments.OpenShiftClusterDocuments...)
	}

	return allopenShiftClusterDocuments, nil
}

func (c *openShiftClusterDocumentClient) Create(partitionkey string, newopenShiftClusterDocument *pkg.OpenShiftClusterDocument, options *Options) (openShiftClusterDocument *pkg.OpenShiftClusterDocument, err error) {
	headers := http.Header{}
	headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)

	if options == nil {
		options = &Options{}
	}
	options.NoETag = true

	err = c.setOptions(options, newopenShiftClusterDocument, headers)
	if err != nil {
		return
	}

	err = c.do(http.MethodPost, c.path+"/docs", "docs", c.path, http.StatusCreated, &newopenShiftClusterDocument, &openShiftClusterDocument, headers)
	return
}

func (c *openShiftClusterDocumentClient) List() OpenShiftClusterDocumentIterator {
	return &openShiftClusterDocumentListIterator{openShiftClusterDocumentClient: c}
}

func (c *openShiftClusterDocumentClient) ListAll() (*pkg.OpenShiftClusterDocuments, error) {
	return c.all(c.List())
}

func (c *openShiftClusterDocumentClient) Get(partitionkey, openShiftClusterDocumentid string) (openShiftClusterDocument *pkg.OpenShiftClusterDocument, err error) {
	headers := http.Header{}
	headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)
	err = c.do(http.MethodGet, c.path+"/docs/"+openShiftClusterDocumentid, "docs", c.path+"/docs/"+openShiftClusterDocumentid, http.StatusOK, nil, &openShiftClusterDocument, headers)
	return
}

func (c *openShiftClusterDocumentClient) Replace(partitionkey string, newopenShiftClusterDocument *pkg.OpenShiftClusterDocument, options *Options) (openShiftClusterDocument *pkg.OpenShiftClusterDocument, err error) {
	headers := http.Header{}
	headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)

	err = c.setOptions(options, newopenShiftClusterDocument, headers)
	if err != nil {
		return
	}

	err = c.do(http.MethodPut, c.path+"/docs/"+newopenShiftClusterDocument.ID, "docs", c.path+"/docs/"+newopenShiftClusterDocument.ID, http.StatusOK, &newopenShiftClusterDocument, &openShiftClusterDocument, headers)
	return
}

func (c *openShiftClusterDocumentClient) Delete(partitionkey string, openShiftClusterDocument *pkg.OpenShiftClusterDocument, options *Options) (err error) {
	headers := http.Header{}
	headers.Set("X-Ms-Documentdb-Partitionkey", `["`+partitionkey+`"]`)

	err = c.setOptions(options, openShiftClusterDocument, headers)
	if err != nil {
		return
	}

	err = c.do(http.MethodDelete, c.path+"/docs/"+openShiftClusterDocument.ID, "docs", c.path+"/docs/"+openShiftClusterDocument.ID, http.StatusNoContent, nil, nil, headers)
	return
}

func (c *openShiftClusterDocumentClient) Query(partitionkey string, query *Query) OpenShiftClusterDocumentIterator {
	return &openShiftClusterDocumentQueryIterator{openShiftClusterDocumentClient: c, partitionkey: partitionkey, query: query}
}

func (c *openShiftClusterDocumentClient) QueryAll(partitionkey string, query *Query) (*pkg.OpenShiftClusterDocuments, error) {
	return c.all(c.Query(partitionkey, query))
}

func (c *openShiftClusterDocumentClient) setOptions(options *Options, openShiftClusterDocument *pkg.OpenShiftClusterDocument, headers http.Header) error {
	if options == nil {
		return nil
	}

	if !options.NoETag {
		if openShiftClusterDocument.ETag == "" {
			return ErrETagRequired
		}
		headers.Set("If-Match", openShiftClusterDocument.ETag)
	}
	if len(options.PreTriggers) > 0 {
		headers.Set("X-Ms-Documentdb-Pre-Trigger-Include", strings.Join(options.PreTriggers, ","))
	}
	if len(options.PostTriggers) > 0 {
		headers.Set("X-Ms-Documentdb-Post-Trigger-Include", strings.Join(options.PostTriggers, ","))
	}

	return nil
}

func (i *openShiftClusterDocumentListIterator) Next() (openShiftClusterDocuments *pkg.OpenShiftClusterDocuments, err error) {
	if i.done {
		return
	}

	headers := http.Header{}
	headers.Set("X-Ms-Max-Item-Count", "-1")
	if i.continuation != "" {
		headers.Set("X-Ms-Continuation", i.continuation)
	}

	err = i.do(http.MethodGet, i.path+"/docs", "docs", i.path, http.StatusOK, nil, &openShiftClusterDocuments, headers)
	if err != nil {
		return
	}

	i.continuation = headers.Get("X-Ms-Continuation")
	i.done = i.continuation == ""

	return
}

func (i *openShiftClusterDocumentQueryIterator) Next() (openShiftClusterDocuments *pkg.OpenShiftClusterDocuments, err error) {
	if i.done {
		return
	}

	headers := http.Header{}
	headers.Set("X-Ms-Max-Item-Count", "-1")
	headers.Set("X-Ms-Documentdb-Isquery", "True")
	headers.Set("Content-Type", "application/query+json")
	if i.partitionkey != "" {
		headers.Set("X-Ms-Documentdb-Partitionkey", `["`+i.partitionkey+`"]`)
	} else {
		headers.Set("X-Ms-Documentdb-Query-Enablecrosspartition", "True")
	}
	if i.continuation != "" {
		headers.Set("X-Ms-Continuation", i.continuation)
	}

	err = i.do(http.MethodPost, i.path+"/docs", "docs", i.path, http.StatusOK, &i.query, &openShiftClusterDocuments, headers)
	if err != nil {
		return
	}

	i.continuation = headers.Get("X-Ms-Continuation")
	i.done = i.continuation == ""

	return
}
